// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/7de6c3dd94feaeb21f20054b9f30d5dabc5efabd/estree/estree.d.ts
// Type definitions for ESTree AST specification
// Project: https://github.com/estree/estree
// Definitions by: RReverser <https://github.com/RReverser>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

declare namespace ESTree {
  interface Node {
    type: string;
    loc?: SourceLocation;
    range?: [number, number];
    leadingComments?: any[];
    trailingComments?: any[];
  }

  interface SourceLocation {
    source?: string;
    start: Position;
    end: Position;
  }

  interface Position {
    line: number;
    column: number;
  }

  interface Program extends Node {
    type: 'Program';
    body: Array<Statement>;
  }

  type Expression = ThisExpression | ArrayExpression | ObjectExpression | FunctionExpression | SequenceExpression | UnaryExpression | BinaryExpression | AssignmentExpression | UpdateExpression | LogicalExpression | ConditionalExpression | MemberExpression | Identifier | Literal | CallExpression | NewExpression;

  interface Function extends Node {
    id?: Identifier;
    params: Array<Identifier>;
    body: BlockStatement;
  }

  interface _Statement extends Node {}

  type Statement = EmptyStatement | BlockStatement | ExpressionStatement | IfStatement | LabeledStatement | BreakStatement | ContinueStatement | WithStatement | SwitchStatement | ReturnStatement | ThrowStatement | TryStatement | WhileStatement | DoWhileStatement | ForStatement | ForInStatement | DebuggerStatement | Declaration;

  interface EmptyStatement extends _Statement {
    type: 'EmptyStatement';
  }

  interface BlockStatement extends _Statement {
    type: 'BlockStatement';
    body: Array<Statement>;
  }

  interface ExpressionStatement extends _Statement {
    type: 'ExpressionStatement';
    expression: Expression;
  }

  interface IfStatement extends _Statement {
    type: 'IfStatement';
    test: Expression;
    consequent: Statement;
    alternate?: Statement;
  }

  interface LabeledStatement extends _Statement {
    type: 'LabeledStatement';
    label: Identifier;
    body: Statement;
  }

  interface BreakStatement extends _Statement {
    type: 'BreakStatement';
    label?: Identifier;
  }

  interface ContinueStatement extends _Statement {
    type: 'ContinueStatement';
    label?: Identifier;
  }

  interface WithStatement extends _Statement {
    type: 'WithStatement';
    object: Expression;
    body: Statement;
  }

  interface SwitchStatement extends _Statement {
    type: 'SwitchStatement';
    discriminant: Expression;
    cases: Array<SwitchCase>;
  }

  interface ReturnStatement extends _Statement {
    type: 'ReturnStatement';
    argument?: Expression;
  }

  interface ThrowStatement extends _Statement {
    type: 'ThrowStatement';
    argument: Expression;
  }

  interface TryStatement extends _Statement {
    type: 'TryStatement';
    block: BlockStatement;
    handler?: CatchClause;
    finalizer?: BlockStatement;
  }

  interface WhileStatement extends _Statement {
    type: 'WhileStatement';
    test: Expression;
    body: Statement;
  }

  interface DoWhileStatement extends _Statement {
    type: 'DoWhileStatement';
    body: Statement;
    test: Expression;
  }

  interface ForStatement extends _Statement {
    type: 'ForStatement';
    init?: VariableDeclaration | Expression;
    test?: Expression;
    update?: Expression;
    body: Statement;
  }

  interface _ForInStatement extends _Statement {
    left: VariableDeclaration | Expression;
    right: Expression;
    body: Statement;
  }

  interface ForInStatement extends _ForInStatement {
    type: 'ForInStatement';
  }

  interface DebuggerStatement extends _Statement {
    type: 'DebuggerStatement';
  }

  interface _Declaration extends _Statement {}

  type Declaration = FunctionDeclaration | VariableDeclaration;

  interface FunctionDeclaration extends Function, _Declaration {
    type: 'FunctionDeclaration';
    id: Identifier;
  }

  interface VariableDeclaration extends _Declaration {
    type: 'VariableDeclaration';
    kind: 'var';
    declarations: Array<VariableDeclarator>;
  }

  interface VariableDeclarator extends Node {
    type: 'VariableDeclarator';
    id: Identifier;
    init?: Expression;
  }

  interface _Expression extends Node {}

  interface ThisExpression extends _Expression {
    type: 'ThisExpression';
  }

  interface ArrayExpression extends _Expression {
    type: 'ArrayExpression';
    elements: Array<Expression>;
  }

  interface ObjectExpression extends _Expression {
    type: 'ObjectExpression';
    properties: Array<Property>;
  }

  interface Property extends Node {
    type: 'Property';
    key: Identifier | Literal;
    value: Expression;
    kind: "init" | "get" | "set";
  }

  interface FunctionExpression extends Function, _Expression {
    type: 'FunctionExpression';
  }

  interface SequenceExpression extends _Expression {
    type: 'SequenceExpression';
    expressions: Array<Expression>;
  }

  interface UnaryExpression extends _Expression {
    type: 'UnaryExpression';
    operator: UnaryOperator;
    argument: Expression;
  }

  interface BinaryExpression extends _Expression {
    type: 'BinaryExpression';
    operator: BinaryOperator;
    left: Expression;
    right: Expression;
  }

  interface AssignmentExpression extends _Expression {
    type: 'AssignmentExpression';
    operator: AssignmentOperator;
    left: Identifier | MemberExpression;
    right: Expression;
  }

  interface UpdateExpression extends _Expression {
    type: 'UpdateExpression';
    operator: UpdateOperator;
    argument: Expression;
    prefix: boolean;
  }

  interface LogicalExpression extends _Expression {
    type: 'LogicalExpression';
    operator: LogicalOperator;
    left: Expression;
    right: Expression;
  }

  interface ConditionalExpression extends _Expression {
    type: 'ConditionalExpression';
    test: Expression;
    alternate: Expression;
    consequent: Expression;
  }

  interface _CallExpression extends _Expression {
    callee: Expression;
    arguments: Array<Expression>;
  }

  interface CallExpression extends _CallExpression {
    type: 'CallExpression';
  }

  interface NewExpression extends _CallExpression {
    type: 'NewExpression';
  }

  interface MemberExpression extends _Expression, _Pattern {
    type: 'MemberExpression';
    object: Expression;
    property: Expression;
    computed: boolean;
  }

  interface _Pattern extends Node {}

  interface SwitchCase extends Node {
    type: 'SwitchCase';
    test?: Expression;
    consequent: Array<Statement>;
  }

  interface CatchClause extends Node {
    type: 'CatchClause';
    param: Identifier;
    body: BlockStatement;
  }

  interface Identifier extends Node, _Expression, _Pattern {
    type: 'Identifier';
    name: string;
  }

  interface _Literal extends _Expression {
    type: 'Literal';
  }

  interface _SimpleLiteral extends _Literal {
    value?: string | boolean | number;
  }

  interface RegExpLiteral extends _Literal {
    value: RegExp;
    regex: {
      pattern: string;
      flags: string;
    };
  }

  type Literal = _SimpleLiteral | RegExpLiteral;

  type UnaryOperator = "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";

  type BinaryOperator = "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "|" | "^" | "&" | "in" | "instanceof";

  type LogicalOperator = "||" | "&&";

  type AssignmentOperator = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=";

  type UpdateOperator = "++" | "--";
}
